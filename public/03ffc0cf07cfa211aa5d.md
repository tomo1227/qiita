---
title: Rust入門1
tags:
  - Rust
private: true
updated_at: '2024-05-25T23:22:07+09:00'
id: 03ffc0cf07cfa211aa5d
organization_url_name: null
slide: false
ignorePublish: false
---
# Rustを始めよう

## 1.1 Rustを始めるには

```rust
fn main(){}
```

* fn : functionを略したキーワード
* main : 関数の名前

Rustのプログラムは絶対1個のエントリポイントがある(main)

RustのツールセットはOSごとに以下3種類のバージョンがある。

* stable(推奨)
* beta
* nightly

```shell-session:terminal
$ rustc -V
```

## 1.2 Hello, World!

```rust
$ rustc -V
rustc 1.78.0 (9b00956e5 2024-04-29)
```

* print : マクロの名前。関数ではない。
* ! : その前がマクロであることを表す

* マクロ呼び出し : コンパイラに対し、そのマクロの呼び出しをマクロ定義の本文で置き換える
* 関数コール : 別の場所で定義された関数のコードをランタイムに実行する。実行の制御は別の官署に移る

Rustは、大文字小文字は区別される

`print!("{} {}!", "hello", "world");`というcみたいな書き方もできる
Cとの違いは、`print!("{}!", "hello", "world");` や ``print!("{} {}!", "hello");`とするとCは警告が出るだけだが、Rustはコンパイルエラーとなる、

Rustでは常に大文字小文字が区別される。

```rust
fn Main() {}
```

とすると、main関数がないのでエラーが出ます。

## 1.3 リテラル文字列を組み合わせてプリントする

```rust
print!("{},{}!", "Hello", "world"); // Hello world
```

また、以下のようにも書ける

```rust
printf("%s, %s!", "Hello", "world");
```

## 1.4 複数行のテキストをプリントする

```rust
print!("First line\nSecond line\nThird line\n");
```

```
First line
Second line
Third line
```

また、`println!()`を使うと出力の最後に改行をつけれます。

## 1.4 整数のプリント

以下の140はリテラル整数。

```rust
print!("My number:{}", 140);
```

コンパイラは、140という文字列を10進数とsいて解釈し、2進数に変換し、そのバイナリを実行プログラムに保存する。プログラムはそのバイナリを読み出し、10進数の140という文字列に変換して、プレースホルダーを置換する。そして、プリントすべき文字列を生成し、ターミナルに出力する。

なので、以下は先頭のゼロが無視され、140が出力される。

```rust
print!("My number:{}", 000140);
```

## 1.6 コメント

```rust
// 行コメント
print!("Hello")
/*
複数行コメント
*/
```

# 数値演算

## 2.1 整数の加算

```rust
print!("{}", 1 + 2")
```

## 2.2 その他の整数演算

C言語で使える算術演算子はどれも使うことができる。

## 2.3 浮動小数点演算

```rust
print!("{}", 80.3 + 34.9); // 115.1999999999
```

この現象は浮動小数点形式を使っているので起きる。

Rustでは、整数と浮動小数点数を混在できない。

```rust
print!("{}", 2.7 + 1); // コンパイルエラー
print!("{}", 2.7 + 1.); // OK
```

## 2.4 文の並び

* 関数内の行は、4個の空白でインデントする
* 文の中で複数の空白を並べるのは避ける
* 80桁を超える行を避ける。長い分は可能な限り複数行に分ける

## 2.5 リテラル文字列の行分け

```rust
fn main(){
    println!("{}", "These\n\
        are\n\
        three lines");
}
```

とすると、以下のように出力される

```
These
are 
three lines
```

# オブジェクトに名前をつける

## 3.1 値に名前をつける

* 値 : 抽象的で数学的な概念
* オブジェクト : ある値を含む1箇所のメモリ
* 変数 : 識別子とオブジェクトのペア

オブジェクトのためにメモリ領域を確保することをオブジェクトのアロケーションと呼ぶ。逆に、オブジェクトを削除する操作をデアロケーションという。

リテラルの値は非可変

```rust
let number = 1; 
print!("{} {}", number, 4);
```

## 3.2 可変変数

ミュータブルな変数を使用すると、代入する際に、オブジェクトをアロケートしない。

```rust
let mut number = 1;
print!("{}", number); // 1
number = 3;
print!("{}", number); // 3
```

## 3.3 変更されないミュータブル変数

以下のようにすると、変更されないので、警告が出る。

```rust
let mut number = 12;
println!("{}", number);
```

## 3.4 初期化されない変数

* どの変数も、その変数を評価する文よりも前に、初期化しておく必要がある
* イミュータブル変数に再代入することはできない
* もしミュータブル変数に代入が１つもなければ、コンパイラが警告を出すことになる

## 3.5 先頭のアンダースコア

```rust
let number = 12; // 使われていないので警告が出る
```

`_`をつけると警告を無視するようにできる。

```rust
let _number = 12; // 警告は出ない
```

また、アンダースコア単体で使用すると、使用せずに捨てる変数という意味となる。

```rust
let _ = 12;
```

## 3.6 ブール値

```rust
let flag = true;
let flag2 = false;
print!("{} {}", flag, flag2);
```

一般的な関係演算子も使用できる

## 3.7 ブール式

論理結合子 も使える

* 否定 : !
* 論理積 : &&
* 論理和 : ||

## 3.8 代入における型の一致

型が違うとコンパイルエラーになる。

## 3.9 型推論

変数の方は、いわゆる型推論により、初期化に使われた式の型から推定することが可能。

## 3.10 型や可変性を変更する

Rust以外では結構禁止されているが、Rustでは再宣言ができる。
再宣言することで、型や可変性を変更できる。
再宣言すると、シャドーイングする。

## 3.11 複合代入演算子

`a = a + 1;`はC言語のように`a += 1`とかける。

## 3.12 標準ライブラリの関数を使う

Rustはデフォルトで標準ライブラリ全体をインクルードしてくれる。

```rust
print!("{} {}", str::len("abcd"), "abcd".len());
```

* プロシージャ形式 : `str::len("abcd")`
* オブジェクト指向形式 : `"abcd".len()`

オブジェクト指向形式が推奨される。

# 実行の流れを制御する

## 4.1 条件文

```rust
let a = 1;
if a > 0 { println!("good"); }
```

elseも使うと

```rust
let a = 1;
if a > 0 {
    println!("good");
} else {
    println!("bad");
}
```

## 4.2 条件式

```rust
let a = 3;
if a > 3 {
    println!("excellent");
} else if a > 0{
    println!("good");
} else {
    println!("bad");
}
```

## 4.3 条件ループ

```rust
let mut a = 3;
while a < 10 {
    println!(a);
    a += 1;
}
```
`break`と`continue`もある。

## 4.4 無限ループ

`while true{}`とすると、`loop{}`を使うように警告が出る。
これはloopの方がわかりやすいからである。

## 4.5 カウント付きループ

2重ドット`..`は**右側を含まない範囲演算子**。

```rust
for n in 1..5 {
    print!("{} ", n); // 1 2 3 4 
}
```

`..=`　は**右側を含む範囲演算子**。


```rust
for n in 1..5 {
    print!("{} ", n); // 1 2 3 4 5 
}
```

for文の中はスコープが変わるので、既出の名前を使うとシャドーイングする。

## 4.6 変数のスコープ

変数のスコープは、`{}`によって変わる。

