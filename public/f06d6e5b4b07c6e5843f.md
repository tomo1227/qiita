---
title: goroutine
tags:
  - Go
private: true
updated_at: '2024-01-22T00:14:23+09:00'
id: f06d6e5b4b07c6e5843f
organization_url_name: null
slide: false
ignorePublish: false
---
# 10章 並行処理

Goの並行性のモデルは[CSP](https://ja.wikipedia.org/wiki/Communicating_Sequential_Processes)(Communicating Sequential Processes)に基づいている。CSPはTony Hoareの1978年の論文[Communicating
Sequential Processes](https://dl.acm.org/doi/pdf/10.1145/359576.359585)で述べられている。

 ![スクリーンショット 2024-01-16 10.23.34.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/156096/a00d53ba-4fe2-7600-d814-1382b5d6e204.png)

## 10.1　並行性をいつ利用するべきか

やってはいけないこと

1. なんでもかんでもゴルーチンに入れる
2. 全然早くならないからチャネルにバッファを追加する
3. チャネルがブロックして、デッドロックになったので、バッファ付きのチャネルを使用してバッファを限りなく大きくする
4. mutexを使おう
5. 諦める

## 10.2　ゴルーチン

goroutineは、Goの並行性モデルの中核となる概念。

* プロセス : 具体的なプログラムがコンピュータのOSによって実行されているもの。
* スレッド : 実行の単位。OSから決められた時間が与えられて実行される。1つのプロセスは1以上のスレッドから成る。

ゴルーチンはGoのランタイムによって管理される軽いスレッド。
Goのプログラムが開始されるとき、Goのランタイムが、プログラムを実行するためにいくつかのスレッドを生成し、一つのゴルーチンを起動する。

関数の前に"go"を付けて、実行するだけでgoroutineが生成

```go
go function()
```

無名関数も可能。

```go
go func() {
...  
}()
```

```go
package main

import (
	"fmt"
)

func Say(s string) {
	fmt.Println(s)
}

func main() {

	go Say("hello")
	go Say("world")

}
```

## 10.3 チャネル

ゴルーチンは、情報のやり取りにチャネル(channel)を使う。チャネルもスライスやマップと同様に組み込みの型。参照型。
関数にチャネルを渡すとき、実際はチャネルへのポインタを渡す。チャネルのゼロ値はnil。

```go:チャネルの生成
ch := make(chan int)
```

### 10.3.1　読み込み、書き込み、バッファリング

`<-`を使う。

```go
a := <- ch // チャネル変数chから値を読みこみ、aに代入する
ch <- b // チャネルへの書き込み。bの値をチャネル変数chに書き込む
```

チャネルに書き込まれた値は一度だけ読み込むことができる。同じチャネルから複数のゴルーチンが読み込みを行っている場合、チャネルに書かれた値は、そのうちの一つのゴルーチンからのみ読み込まれる。
一つのゴルーチンが同じチャネルに対して読み書き両方を行うのは一般的ではない。

デフォルトでは、チャネルはバッファリングされない。オープンされてバッファリングされていないチャネルへの書き込みが行われる時、書き込みがわのゴルーチンは、同じチャネルから他のゴルーチンが読み込みを行うまで停止する。同様に、オープンされ、バッファリングされていないチャネルからの読み込みを行っているゴルーチンは同じチャネルへ他のゴルーチンが書き込みを行うまで停止することになる。ゆえに、バッファリングされていないチャネルへの書き込み(あるいはバッファリングされていないチャネルからの読み込み)は、複数のゴルーチンが平行に実行されていないと起こり得ない。

バッファ付きの（バッファリングされる) チャネルもある。バッファ付きのチャネルに対しては、ブロックされることなしに、特定の回数の書き込みが行われる。バッファがいっぱいになると、それ以降のチャネルへの書き込みは一旦停止され、書き込みがわのゴルーチンはチャネルから読み込みが行われるまでブロックすることになる。同じように、バッファが空のチャネルから読み込みを行おうとするとブロックされる。

バッファリングされるチャネルの生成

```go
ch := make(chan int, 10)
```

ほとんどの場合はバッファリングされないチャネルを使うべきである。

### 10.3.2 for-rangeとチャネル

`for-range` を使うと、チャネルからの読み込みを行うことができる。

```go
for v := range ch {
    fmt.Println(v)
}
```

チャネルに関し宣言される変数は一つしかなく、それに値が代入される。この場合、チャネルがクローズされるまで、あるいはbreak文あるいはreturn文に出会うまでループする。

### 10.3.3 チャネルのクローズ

`close(ch)`でチャネルを閉じることができる。

クローズ後は書き込みや再度クローズしようとすると、パニックになる。読み込みは成功する。

クローズされたチャネルがバッファを持っており、まだ読まれていない値がある場合は、その値が順番に返される。
バッファリングされていないチャネルであるか、バッファに値が残っていない場合はチャネルの型のゼロ値が返される。

チャネルから読み込みを行う際は「書き込まれたゼロ値」と「チャネルがクローズされていたために戻されたゼロ値」とを区別しなければならない。
カンマokイディオムを使ってチャネルがクローズされたかどうかを検知する。

```go
v, ok := <-ch
```

okがtrueならば、チャネルはオープンしており、vにはチャネルchから読み込まれた値が入っている。
okがfalseならば、チャネルはクローズで、vにはゼロ値が入っている。

### 10.3.4　チャネルの動作

||バッファ無 + 開|バッファ無 + 閉| バッファ有 +開|　バッファ有 +閉|nil|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| 読み込み|停止 |

特にパニックになる以下2つには注意。

* 同じチャネルを二度クローズする
* 一つのゴルーチン内でチャネルをクローズした後で別のゴルーチンがそのチャネルへ書き込む

## 10.4 select

Goにおける並行性の制御構造そのもので、平行操作の優先順をエレガントに解決する。
どれかをいつも優先すると、場合によってはスターベーションが起こる。(スターべーションのもっとも発生しやすくもっとも深刻な状況が，デッドロック)

`select`を使うことで、複数のチャネルに対する読み込み、あるいは書き込みの操作が可能になる。ブランクswitchと似ている。
switchは上から順番にチェックするのに対して、select文のcaseは実行順序には関係なく、データの準備ができているcaseから **ランダム** に選択する。

[https://go.dev/play/p/bjQrSrn4kPI](select文の例)

また、selectがランダムに選択することによって、デッドロックの原因の１つである、**整合性がない順番でロックを取得すること** を防ぐ。
デッドロックになると`fatal error: all goroutines are asleep - deadlock!`といったエラーが表示される。

[1行でデッドロック](https://go.dev/play/p/5rgmh0r4ufh)

[デッドロックの例ex1003](https://go.dev/play/p/MCGCLBMB7SE)

[selectでデッドロックが解消する例ex1004](https://go.dev/play/p/qSTjx2l02fK)

selectは以下のように回文で使われることが多く、よく**for-selectループ**と言われる。

```go
for {
    select {
        case <- done:
            return
        case v := <-ch
            fmt.Println(v)
    }
}
```

select文でもdefaultを設定できる。defaultは前に進めるcaseがない場合に選択される。

```go
select {
    case v := <- ch:
        fmt.Println("chから読み込み:", v)
    default: 
        fmt.Println("chに書き込まれた値なし")
}
```


## 10.5 並行処理のベストプラクティスとパターン



### 10.5.1 APIに並行性は含めない

並行性は実装に関する詳細情報。実装の詳細はAPIとして表には出してはいけない。
表に出すAPIを変えることなく実装方法を変更できるため。

APIとして公開する型、関数、メソッドにチャネルを含めないようにする。
チャネルを表に出すとチャネル管理の責任をAPIのユーザに負わせることになってしまう。
チャネルがバッファリングされているか、クローズされたか、nilかどうかを利用者が気にしなければならなくなる。想定されていない順序でチャネルにアクセスすることで、デッドロックを招くことになる。

### 10.5.2　ゴルーチンとforループ

forループ内のゴルーチンが外側のループの値を使用すると、どのループ時点での値かが不定となる。

[ex1005.go](https://go.dev/play/p/2TLp3sKqjgX)

```go
a := []int{2, 4, 6, 8, 10, 12, 14, 16, 18, 20} //liststart
ch := make(chan int, len(a))
for _, v := range a {
    go func() {
        ch <- v * 2
    }()
}
for i := 0; i < len(a); i++ {
    fmt.Print(<-ch, " ")
} //listend
fmt.Println()
```

for文の最後まで到達して、ゴルーチンが全てt起動していれば、vは20になるが、そうでなければさまざまな値をvはとる。


ループ内でシャドーイングすることで、解決する。
[ex1005b.go](https://go.dev/play/p/ZS8bFaHJ5ki)

```diff_go
	a := []int{2, 4, 6, 8, 10, 12, 14, 16, 18, 20}
	ch := make(chan int, len(a))
	for _, v := range a { //liststart
+		v := v  // 外側のvをシャドーする
		go func() {
			ch <- v * 2
		}()
	} //listend
	for i := 0; i < len(a); i++ {
		fmt.Print(<-ch, " ")
	}
	fmt.Println()
```

for文以外にも、外側の変数にgorotineが依存している場合は、同じ問題が生じる。

他の解決策として、goroutineの引数に値を渡す方法もある。[ex1005c.go](https://go.dev/play/p/qAShOz0M9x4)

```diff_go:
a := []int{2, 4, 6, 8, 10, 12, 14, 16, 18, 20}
ch := make(chan int, len(a))
for _, v := range a { //liststart
    go func(val int) { // valの値は下の引数vの値になる
        ch <- val * 2
    }(v)  // vの値を無名関数に引数で渡す
} //listend
for i := 0; i < len(a); i++ {
    fmt.Print(<-ch, " ")
}
fmt.Println()
```

### 10.5.3 ゴルーチンの終了チェック

gorotineとして実行される関数を起動する場合は **確実に終了させる** 必要がある。
変数と違い、未使用のgoroutineは検知されない。goroutineが終了しない場合は、スケジューラは定期的にgoroutineに時間を割くので、全体の動作が遅くなる。(**ゴルーチンリーク** と呼ぶ)

速い：[ex1006.go](https://go.dev/play/p/gWO-LsruKrA)

breakしているので、遅い : [ex1006b.go](https://go.dev/play/p/Ctg2ggWVZMw)

### doneチャネルパターン

**doneチャネルパターン** を使用すると、goroutineに対して、処理を終了するべきであるというシグナルを送ることができる。
[ex1007.go](https://go.dev/play/p/ooS2opNKS5M)
[ex1007b.go(詳細版)](https://go.dev/play/p/Fbe2XTJfNwm)

```go
// 文字列sに関して、convertersに入っている関数を並行に実行して、もっとも早く終了した結果を返す
// 第1引数sは対象の文字列
// 第2引数convertersは「『文字列を受け取って、文字列を返す関数』を要素としてもつスライス」
// 戻り値は文字列
func convertData(s string, converters []func(string) message) message {
	done := make(chan struct{}) //空の構造体チャネル
	resultChan := make(chan message)
	for _, f := range converters {
		go func(f func(string) message) {
			r := f(s)
			select{
			case resultChan <- r:
				fmt.Printf("結果が戻ってきたのでresultChanに入れたあと: %v\n", r)
			case <- done:
					fmt.Println("case<-done選択", r.fromFunc)
			}
			fmt.Println("無名関数終了",r)
		}(f)
	}
	r := resultChan // 結果が返ってきたら
	close(done)	// チャネルをクローズ
	return r
}
```

* select文の各caseで、resultチャネルへの書き込みか、doneチャネルへの書き込みを待つ
* オープンされたチャネルからの読み込みはデータの準備ができるまでポーズする
* クローズされたチャンネルの場合は常にそのチャネルのゼロ値が変える。
* 処理の最後に、resultに書き込まれた最初の値を読み込み、doneチャネルをcloseする(これがgoroutineの終了のシグナルとなり、ゴルーチンリークを防止する)

12.2 では、コンテキストを用いて、ゴルーチンが終了するべき時であることを伝える方法を説明します。

### 10.5.5 キャンセレーション関数を用いたゴルーチンの終了

[ex1008.go](https://go.dev/play/p/CmvvlR9lAxK)

チャネルだけでなく、処理をキャンセルするためのキャンセラレーション関数も戻すことで、goroutineの実行をキャンセルしたくなったときにキャンセルできるようにできる。

### 10.5.6 いつバッファ付きのチャネルを使うべきか

デフォルトではチャネルはバッファリングされない。(リレーのバトンのように単純な受け渡し)
バッファ付きのチャネルの動作は複雑になる。正しく使うには、バッファがいっぱいになった場合にどう対処するかを記述しなければならない。

バッファを使うのが有用なのは以下２つを満たすとき。

* goroutineがいくつ起動したか分かっている
* 起動するgoroutineの数を制限したい、もしくはバッファに入ったものの処理に制限をかけたい

例えば以下のような場合が挙げられる。

* 起動した一群のgoroutineからデータを集めるとき
* 並行実行の程度を制限したいとき
* システムがキューに入れた処理の量を管理して、関連する処理あるいは、プログラム全体の処理が遅くなってしまうのを防止したいとき

[ex1009.go](https://go.dev/play/p/fX-PIv0vlya)

### 10.5.7 バックプレッシャ

バッファ付きチャネルを使用するテクニックの一つに**バックプレッシャ**がある。

特定のコンポーネントの仕事の量を制限して、システムが全体として効率よく動作するように、バッファ付きチャネルとselect文を使って同時リクエストの数を制限する。

[ex10010.go](https://github.com/mushahiroyuki/lgo/blob/main/example/ch10/ex1010.go)

### 10.5.8　selectにおけるcaseの無効化

* case文のチャネルがクローズされた際、チャネル読み込みは成功するが、常にゼロ値が返る。
    * これは無駄な処理であるため、以降はスキップするよう対応が必要。
* チャネルがクローズされたら、チャネルにnilを設定することで、以降該当のcaseをスキップできる

[ex10010.5.go](https://go.dev/play/p/PaB83kKOh2W)

チャネルをnilにすることでselectの一つのcaseを無効化することができる。
caseにおいてはnilチャネルからの読み込みを返さないため、該当のcaseは実行されない。

### 10.5.9 タイムアウト

ほとんどの対話的なプログラムは所定の時間内にレスポンスを返す必要がある。Goの並行処理ではリクエストの実行時間を管理できる。他の言語では、プロミスやフィーチャーといった概念を導入していますが、Goでは、タイムアウトのイディオムを使うことで、比較的簡単に実現できる。

[ex10011.go](https://go.dev/play/p/jzTnZ6mBSpV)

### 10.5.10 WaitGroupの利用

1つのgoroutineが複数のgoroutineの処理の終了を待たなければならない。

* WaitGroupを使うすべての場所で同じインスタンスが使われるようにするため。WaitGroupに渡したにも関わらず、ポインタを使わないとその関数はコピーを持ち、Doneへの呼び出しがオリジナルのWaitGroupをデクリメントしない。
* デザイン。並行性はAPIには含めないようにするため。

1つのgoroutineを待つ場合は[doneチャネルのパターン]()を使う。
複数ある場合は、標準ライブラリのパッケージsyncにある[WaitGroup](https://pkg.go.dev/sync#WaitGroup)を使う必要がある。

[ex10012.go](https://go.dev/play/p/_lINa2jP0wx)

WaitGroupは明示的な初期化の必要はない。宣言するだけで、ゼロ値を使う。
以下3つのメソッドがある。

* Add : 終了を待つgoroutine数のカウンタを指定した数だけ増やす
* Done : カウンタをデクリメントする。処理が終了した時に呼ばれる
* Wait : カウンタが0になるまで、それを含むgoroutineを停止する

以下は複数の値を複数のgoroutineで同時に処理して、結果をスライスに集め、そのスライスを返す関数。

 [ex10013.go](https://go.dev/play/p/nG1xITilTAu)

 WaitGroupは便利だが、goroutineの協調のための第一の選択肢とするべきではない。処理を行うワーカーとなるgoroutineがすべて終了した後で、クリーンアップするものがあるときのみ用いる。

:::note info
errgroupはWaitGroupで作られている。これは一群のgoroutineを生成し、そのうち一つのgoroutineがエラーを返すと処理を停止する。
:::

### 10.5.11 コードを一度だけ実行

initを用いると、イミュータブルなパッケージレベルの状態を初期化することができる。
こうした初期化の処理のほかに、(起動直後にではなく後で)遅延読み込み(lazy load)したいときがある。初期化は比較的時間がかかる場合が多くいつも実行するわけではない時もある。こういう場合には`sync.once`を使用すると、必要な時に一度だけ特定の処理を実行できる。

 [ex10014.go](https://go.dev/play/p/GO5gy-yx0zn)

### 10.5.12 並行処理ツールの協調

3つのWeb Serviceを呼び出す関数がある。3つのうち2つのサービスにデータを送りそれぞれから結果を受け取る。受け取った２つの結果を3つ目のサービスに送り、結果をもらう。すべてのサービスは50msいないで行われる必要があり、その条件が満たされない場合はエラーが返る。

 [ex10014.go](https://github.com/mushahiroyuki/lgo/blob/main/example/ch10/ex1015.go)

## 10.6 チャネルの代わりにmutexを使うべきとき

他のプログラミング言語でスレッド間でデータへのアクセスをうまくやろうとすると **mutex** を使う。mutexによって共有されたデータに対するコードの並行実行やアクセスを制限する。保護された部分のことを **クリティカルセクション** と呼ぶ。mutexのデメリットはプログラムのデータの流れを不明瞭にする。それに対して、チャネルを介してgoroutineからgoroutineに値が渡されるときはデータの流れは明快である。その時点のデータへのアクセスは1つのgoroutineに限定されている。mutexがデータ保護に使われる際には、データの所有権を持っているのが、どのgoroutineなのかを示すものが何もない。データに対するアクセスは並行に実行されているプロセスの全てによって共有されている。このため、処理の順番を理解するのが、難しくなる。このガン替え方をGoのコミュニティでは、メモリの共有でコミュニケーションするのではなく、コミュニケーションによってメモリを共有すると表現している。

mutexを使った方がいいケースは、複数のgoroutineが共有されたデータを読み込んだり、単純な書き込みをしたりするものの、その値は処理しないというケースがある。

* goroutineの関係を調整しようとしている、あるいは一連のgoroutineによって変換されるデータを突ラックしているのならば、チャネルを使うべきである。
* 構造体のフィールドに対するアクセスを共有しているのならば、mmutexを使うべきである。
* チェンるを使う際に致命的なパフォーマンスの問題があり、この問題を修正する方法が見つからないのならば、mutexを使うようにコードを変更するべきである。

mutexの問題として、以下2つが挙げられる。

* mutexを使うと余分なブックキーピングが必要になる。ロックを正しく取得・解除しないと、デッドロックになる。
* Goのmutexはリエントラントではない。1つのgoroutineが同じロックを2度取得しよ右とすると、デッドロックする。Javaはロックがリエントラントである。


リエントラントではない、ロックは、自分自身を再起的に呼び出す関数のロックの取得をトリッキーにする。再起的な関数呼び出しの前にロックを解除しなければならない。関数呼び出しをする際にロックを保持するのは注意が必要。呼び出し中にどのようなロックが取得されるか分からない。ある関数で同じmutexのロックを取得しようとするもう一つ別の関数を呼び出してしまうと、そのgoroutineはデッドロックする。

sync.WaitGroupやsync.Onece同様、mutexはコピーしてはダメ。関数に渡されたり、構造体のフィールドとして、アクセスされたりする際には、ポインタを介さなければならない。mutexがコピーされると、ロックは共有されない。

:::note info
syunc.Mapとい並行実行を行なっても安全なうmapがある。以下のような特殊な場合に用いる。
* 共有マップでkey/valueのペアが一度だけ追加され、何度も読まれる
* 複数のgoroutineがmapを共有する際に、互いに他方が担当するキーと値にはアクセスしない。
:::

## 10.7 sync/atomic

mutex以外にも複数スレッドが関係する場面で、データの一貫性を保つ方法が用意されている。`sync/atomic`には、モダンなCPUに組み込まれたアトミックな変数に対する操作のための機能が組み込まれている。一つのレジスタに十分入る値に他する加算、スワップ、ロード、ストア、比較とスワップ(CAS)のための機能。

パフォーマンスを最高レベルにまで高められる並行実行のエキスパートを自認するなら、Goの`sync/atomic`を使って並行性に纏わる処理を管理すれば十分である。

## 10.8 まとめ

他にも多くの並行性に関するパターンがある。
[Go言語による並行処理](https://www.oreilly.co.jp/books/9784873118468/)がおすすめ。

