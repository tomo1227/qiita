---
title: 【Go言語】range
tags:
  - Go
private: true
updated_at: '2024-08-09T20:45:47+09:00'
id: c2d07644d5f1c4d14bb0
organization_url_name: null
slide: false
ignorePublish: false
---
## はじめに

rangeは式が必須である。例えば、`for i, v := exp`のexpが式となる。

[Go Playground](https://go.dev/play/p/mQebd8N2XUH)

```go
func main() {
	s := []int{0, 1, 2}
	for range s {
		s = append(s, 10)
	}
}
```

rangeを使った時に与えられた式が開始前に1度だけ評価される。
故に上記のコードでは、`s`はrangeが使う一時変数にコピーされる。

![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/156096/8ce35fea-5893-be08-db67-a7e0493afb81.png)

従来のfor文では動作がrangeを使った場合と動作が異なる。

[Go Playground](https://go.dev/play/p/dRTAlT2JAo6)

```go
func main() {
	s := []int{0, 1, 2}
	for i := 0; i < len(s); i++ {
		s = append(s, 10)
	}
}
```

このコードは終了しない。
`len(s)`は反復ごとに評価され、要素を追加し続ける。

## チャネル

rangeを使ったチャネルの反復処理。

[Go Playground](https://go.dev/play/p/4BGGSHroupE)
```go
func main() {
    // 要素0,1,2を含めるための最初のチャネルを作成する
	ch1 := make(chan int, 3)
	go func() {
		ch1 <- 0
		ch1 <- 1
		ch1 <- 2
		close(ch1)
	}()

    // 要素10,11,12を含めるための2つのチャネルを作成する
	ch2 := make(chan int, 3)
	go func() {
		ch2 <- 10
		ch2 <- 11
		ch2 <- 12
		close(ch2)
	}()

	ch := ch1
    // chを反復処理することで、消費チャネルを作成する
	for v := range ch {
		fmt.Println(v) // 0 1 2
		ch = ch2
	}
}
```

rangeに指定された式は、ch1を指すchチャネル。rangeはchを評価して、一時変数にコピーし、そのチャネルの要素に対して、反復処理を行う。`ch = ch2`に関わらず、rangeはch2ではなく、ch1に対して、反復処理を行う。`ch = ch2`は、chに2つ目のチャネルを代入しているので、このコードの後でclose(ch)を呼び出すと、1つ目ではなく、2つ目のチャネルがクローズされる。

## 配列

以下は

```go
func main() {
	a := [3]int{0, 1, 2}
	for i, v := range a {
		a[2] = 10
		if i == 2 {
			fmt.Println(v) // 2
		}
	}
}
```

最後のインデックスの要素を10に更新しているにも関わらず、結果は2が表示される。
range演算子は、配列のコピーを作成して、ループはそのコピーを更新せず、元の配列であるaを更新する。

![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/156096/4a5e57a0-4020-bb5c-8c48-6e80fc32748f.png)

最後の要素の実際の値の表示方法は2つある。

* インデックスを使う方法
* 配列へのポインタを使う方法

### インデックスを使用する

元の配列にアクセスすると、当然更新された10が表示される。

[Go Playground](https://go.dev/play/p/-ZoCIO6turQ)

```go
func main() {
	a := [3]int{0, 1, 2}
	for i := range a {
		a[2] = 10
		if i == 2 {
			fmt.Println(a[2]) // 10
		}
	}
}
```

### 配列へのポインタを使用する

配列へのポインタのコピーをrangeで使用している一時変数に代入することで、同じ配列を参照し、更新した値を表示することが可能になります。

[Go Playground](https://go.dev/play/p/10aNYJaBP3M)

```go
func main() {
	a := [3]int{0, 1, 2}
	for i, v := range &a {
		a[2] = 10
		if i == 2 {
			fmt.Println(v) // 10
		}
	}
}
```

## rangeにおけるポインタ

次のメソッドはキャッシュに要素を挿入するロジックを実装している。

```go
type Store struct {
	m map[string]*Foo
}

func (s Store) Put(id string, foo *Foo) {
	s.m[id] = foo
	// ...
}
```

`Foo`要素は`Put`の呼び出し元と`Store`構造体の両方で共有される。

